'use strict';

const _ = require('lodash');

class Router {

  // Interface =================================================================

  get (url, user) {
    var self = this,
      res = {},
      route = null,
      error = { error404: true };
    self.routes.forEach(item => {
      if (url.search(item.reg) === -1 || route) return;
      route = item;
    });
    if (!route) return error;
    res.args = self.getArguments(url, route);
    res.path = route.path;
    if (res.path && res.path.search('{') > -1) {
      _.each(res.args, function (value, name) {
        res.path = res.path.replace(new RegExp('\\{' + name + '\\}', 'mg'), value);
      });
    }
    res = self.filterResponse(res, route, user || {});
    if (res.error404) return { error404: true };
    if (res.redirect) return { redirect: res.redirect };
    return res;
  }

  getPaths () {
    var self = this;
    return self.routes.map(route => route.path);
  }

  load (data) {
    var self = this,
      routes = [];
    // Parse flat routes
    _.each(data, (path, url) => {
      if (typeof path !== 'string') return;
      routes.push(self.parseRoute(url, path));
    });
    // Parse groups
    _.each(data, (content, name) => {
      if (typeof content === 'string') return;
      _.each(self.parseGroup(name, content), route => {
        routes.push(self.parseRoute(route.url, route.path));
      });
    });
    self.routes = routes;
    let allRoute = null;
    _.each(routes, (route, i) => {
      if (!route) return;
      if (route.url === '*') {
        allRoute = route;
        routes.splice(i, 1);
      }
    });
    if (allRoute) {
      self.routes.push(allRoute);
    }
    return routes;
  }

  // Implementation ==========================================================

  constructor (data) {
    var self = this;

    _.extend(self, {
      routes: [],
      groups: ['u>', 'a>', 's>', '->', 'n>'],
    });

    if (data) {
      self.load(data);
    }
  }

  getArguments (url, route) {
    var self = this,
      result = {};
    url.replace(route.reg, function (...args) {
      var params = args.slice(1, -2);
      params.forEach((param, i) => {
        var name = route.args[i];
        if (name.type === 'number') {
          param = param * 1;
        } else {
          param = decodeURIComponent(param);
        }
        result[route.args[i].name] = param;
      });
    });
    return result;
  }

  filterResponse (res, route, user) {
    var self = this;

    if (!route.mod)
      return res;

    if (route.mod === 'u' && !user.isAuth)
      res.redirect = route.redirect || '/login/';

    if (route.mod === 'n' && user.isAuth)
      res.redirect = route.redirect || '/';

    if (route.mod === 'a' && !user.isAdmin && route.redirect)
      res.redirect = route.redirect;

    if (route.mod === 'a' && !user.isAdmin && !route.redirect)
      res.error404 = true;

    if (route.mod === 's' && !user.isStaff && route.redirect)
      res.redirect = route.redirect;

    if (route.mod === 's' && !user.isStaff && !route.redirect)
      res.error404 = true;

    if (route.mod === '-')
      res.redirect = res.path;

    return res;
  }

  /*
   * Recevies URL and path strings.
   * Returns route object with following props:
   * - url: Source URL string.
   * - path: Source path string.
   * - mod: Modifier symbol or null.
   * - redirect: Redirect string or null.
   * - reg: Regular expression for route's URL.
   * - args: Array of objects with props 'name' and 'type'.
   */
  parseRoute (url, path) {
    var self = this,
      args = [],
      argRe = /[\$\#]\{(.+?)\}/mg,
      route = {
        url: url,
        path: path,
        mod: null,
        redirect: null
      };
    if (url === '*') {
      return {
        url: '*',
        path: path,
        mod: null,
        redirect: null,
        reg: /(.+)/gim,
        args: ['url']
      };
    }
    // Replace and save URL arguments
    url = url.replace(argRe, (str, name) => {
      if (str.charAt(0) === '$') {
        args.push({ name: name, type: 'string' });
        return '(\\w+)';
      }
      args.push({ name: name, type: 'number' });
      return '(\\d+)';
    });
    // url = url.replace(/\#\{(.+?)\}/mg, (str, name) => {
    //   args.push({ name: name, type: 'number' });
    //   return '(\\d+)';
    // });
    // Create RegExp
    url = url.replace(/\//mg, '\\\/');
    route.reg = new RegExp('^' + url + '$', 'mgi');
    route.args = args;
    // Replace and save modifiers
    if (path.charAt(1) === '>') {
      route.mod = path.charAt(0);
      path = path.slice(2);
    }
    // Replace and save redirect
    if (path.indexOf('>') > -1) {
      route.redirect = path.split('>')[1];
      path = path.split('>')[0];
    }
    // Save path
    route.path = path;
    return route;
  }

  /*
   * Receives group name and group content.
   * Returns array of objects with props 'url' and 'path'
   */
  parseGroup (name, content) {
    var self = this,
      group = self.parseGroupName(name),
      result = [];

    _.each(content, (path, url) => {
      var mod = null;
      if (typeof path === 'string') {
        url = group.url + url
        path = self.prefixGroupPath(path, group.path, group.mod);
        return result.push({
          url: url.replace(/\/\//mg, '/'),
          path: path.replace(/\/\//mg, '/')
        });
      }
      let name = self.parseGroupName(url);
      name.url = group.url + name.url;
      name.path = self.prefixGroupPath(
        name.path,
        group.path,
        name.mod || group.mod
      );
      url = `${name.url} : ${name.path}`;
      result = result.concat(self.parseGroup(url, path));
    });
    return result;
  }

  prefixGroupPath (path, prefix, mod) {
    var self = this;

    if (prefix.trim().length > 0 && path.charAt(1) === '>')
      path = path.slice(0, 2) + prefix + '/' + path.slice(2);

    if (prefix.trim().length > 0 && path.charAt(1) !== '>')
      path = prefix + '/' + path;

    if (path.charAt(1) !== '>' && mod)
      path = mod + '>' + path;

    return path;
  }

  parseGroupName (name) {
    var self = this,
      url = '',
      path = '',
      mod = null;
    if (name.indexOf(':') > -1) {
      url = (name.split(':')[0] || '').trim();
      path = (name.split(':')[1] || '').trim();
      if (path.charAt(1) === '>') {
        mod = path.charAt(0);
        path = path.slice(2);
      }
    } else {
      mod = name.charAt(0);
    }
    return {
      url: url,
      path: path,
      mod: mod
    };
  }

}

module.exports = Router;
