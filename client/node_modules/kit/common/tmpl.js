'use strict';

const expression = require('./expression');
const interpolate = require('./interpolate');

const state = {
  counter: 0,
};

class Tag {
  
  constructor (opts = {}) {
    var self = this;
    self.args = opts.args;
    self.context = opts.context;
    self.root = opts.root;
    self.source = opts.source;
    self.uid = `tag-${++state.counter}`;
  }
  
  get (key) {
    var self = this;
    return getProperty(self.context || self.root, key);
  }
  
  getAlias () {
    var self = this;
    return `<<<TAG#${self.uid}>>>`;
  }
  
  getContext (...args) {
    var self = this,
      context = Object.assign({}, self.root, self.context, ...args);
    return context;
  }
  
  express (code, ctx = {}) {
    var self = this;
    return expression(code, self.getContext(ctx));
  }
  
  interpolate (code, ctx = {}) {
    var self = this;
    return interpolate(code, self.getContext(ctx));
  }
  
  render () {
    var self = this;
    return '';
  }
  
  renderContent () {
    var self = this;
    return self.render(...self.args);
  }
  
  createContext (data, name) {
    var self = this,
      ctx = {};
    ctx[name] = data;
    return self.getContext(ctx);
  }
  
}

class ForTag extends Tag {
  
  static get re () {
    var self = this;
    return /\[\[\s*for\s+(.+)\s+in\s+(.+)\]\]([\s\S]+?)\[\[\s*endfor\s*\]\]/mgi;
  }
  
  render (itemName, listName, content) {
    var self = this,
      list = self.get(listName);
    if (!list || !Array.isArray(list)) return '';
    return list
      .map(item => {
        var ctx = self.createContext(item, itemName),
          code = self.interpolate(content, ctx);
        return code;
      })
      .join('\n');
  }
  
}

class IfTag extends Tag {
  
  static get re () {
    var self = this;
    return /\[\[\s*if\s+(.+)\s*\]\]([\s\S]+?)\[\[\s*endif\s*\]\]/mgi;
  }
  
  render (cond, content) {
    var self = this,
      result = self.express(cond);
    if (!result) return '';
    return content;
  }
  
}

class ExprTag extends Tag {
  
  static get re () {
    var self = this;
    return /\[\[\s*(.+)\s*\]\]/mgi;
  }
  
  render (expr) {
    var self = this;
    return self.express(expr);
  }
  
}

const TAGS = [
  IfTag,
  ForTag,
  ExprTag,
];

class Tmpl {
  
  render (code = '', ctx = {}) {
    var self = this,
      root = ctx,
      context = ctx,
      tags = [];
    TAGS.forEach(Tag => {
      code = code.replace(Tag.re, (txt, ...args) => {
        var tag = new Tag({
          args: args
            .filter(arg => arg && typeof arg === 'string')
            .map(arg => arg.trim()),
          context: context,
          root: root,
          source: txt,
        });
        tags.push(tag);
        return tag.getAlias();
      });
    });
    while (code.indexOf('<<<TAG') > -1) {
      tags.forEach(tag => {
        var content = tag.renderContent();
        code = code.replace(tag.getAlias(), content);
      });
    }
    return code;
  }
  
}

module.exports = new Tmpl();

function getProperty(obj, p) {
  var current = obj,
    names = p.split('.'),
    name;
  for (var i = 0; i < names.length - 1; i++) {
    name = names[i];
    if (typeof current[name] !== 'object' || current[name] === null) {
      return defaultValue;
    }
    current = current[name];
  }
  return current[names.pop()];
}
