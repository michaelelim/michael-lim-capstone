'use strict';

const _ = {
  getTypes: require('./get-types'),
  type: require('./type'),
};

const state = {

};

class Overload {

  constructor (name, proto) {
    var self = this;
    self.name = name;
    self.proto = proto;
    self.methods = {};

    Object.defineProperty(proto, name, {

      get () {
        return function (...args) {
          return self.call(...args);
        };
      },

    });
  }

  checkTypes (types) {
    var self = this;
    return types.map(t => _.getTypes.includes(t) ? t : _.type(t));
  }

  method (method, typ = []) {
    var self = this,
      types = self.checkTypes(typ),
      key = types.join('-');
    if (self.methods[key]) return;
    self.methods[key] = method;
  }

  call (...args) {
    var self = this,
      types = args.map(arg => _.type(arg)),
      key = types.join('-'),
      method = self.methods[key];
    if (!method) {
      throw new Error(`Method «${self.name}» of class «${self.proto.constructor.name}» has not overloaded by types (${types.join(', ')})!`);
    };
    return method.apply(self.item, args);
  }

}

function overload (name, ...types) {
  return function (proto, originalName, desc) {
    var o = proto._overload || new Overload(name, proto);
    proto._overload = o;
    o.method(desc.value, types);
  };
}

module.exports = overload;
