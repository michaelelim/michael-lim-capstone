'use strict';

const state = {
  begin: null,
  counter: 0,
  logsCounter: 0,
  timeCounter: 0,
  testCounter: 0,
};

const _ = {
  extend: require('./extend'),
  type: require('./type'),
  isEqual: require('./is-equal'),
  isClass: require('./is-class'),
  inspect: require('./inspect'),
  capitalize: require('./capitalize'),
};

class Test {

  constructor (title, opts = {}) {
    var self = this;
    self.opts = _.extend({
      showAll: false,
    }, opts);
    self.begin = null;
    self.title = title;
    self.uid = `#${++state.testCounter}`;
    self.logs = [];
  }

  get end () {
    var self = this;
    return () => {
      self.finish();
    };
  }

  start () {
    var self = this;
    self.begin = Date.now();
    self.logs = [];
  }

  // Assertions ==============================================================

  type (val, type, desc) {
    var self = this;
    return self.log('type', _.type(val) === type, desc, {
      val: val,
      desc: 'should have type',
      item: type,
    });
  }

  equal (val, other, desc) {
    var self = this;
    return self.log('isEqual', _.isEqual(val, other), desc, {
      val: val,
      desc: 'shoud be equal',
      item: other
    });
  }

  eq (...args) {
    var self = this;
    return self.equal(...args);
  }

  is (val, other, desc) {
    var self = this;
    return self.log('is', val === other, desc, {
      val: val,
      desc: 'should be',
      item: other,
    });
  }

  notInstanceOf (val, Class, desc) {
    var self = this;
    return self.log('notInstanceOf', !(val instanceof Class), desc);
  }

  instanceOf (val, Class, desc) {
    var self = this;
    return self.log('instanceOf', _.isClass(Class) && val instanceof Class, desc, {
      val: val,
      desc: 'should be instance of',
      item: Class,
    });
  }

  notArray (val, desc) {
    var self = this;
    return self.log('notArray', !Array.isArray(val), desc);
  }

  isArray (val, desc) {
    var self = this;
    return self.log('isArray', Array.isArray(val), desc);
  }

  array (...args) {
    var self = this;
    return self.isArray(...args);
  }

  notUndefined (val, desc) {
    var self = this;
    return self.log('notUndefined', val !== undefined, desc);
  }

  isUndefined (val, desc) {
    var self = this;
    return self.log('isUndefined', val === undefined, desc);
  }

  undef (...args) {
    var self = this;
    return self.isUndefined(...args);
  }

  notNull (val, desc) {
    var self = this;
    return self.log('notNull', val !== null, desc);
  }

  isNull (val, desc) {
    var self = this;
    return self.log('isNull', val === null, desc);
  }

  null (...args) {
    var self = this;
    return self.isNull(...args);
  }

  notOk (val, desc) {
    var self = this;
    return self.log('notOk', !val, desc);
  }

  ok (val, desc) {
    var self = this;
    return self.log('ok', !!val, desc);
  }

  assert (val, desc) {
    var self = this;
    return self.log('assert', !!val, desc);
  }

  // Util ====================================================================

  getStack () {
    var self = this;
  }

  time (name = `#${++state.timeCounter}`) {
    var self = this;
    console.time(name);
    return name;
  }

  timeStop (name) {
    var self = this;
    console.timeEnd(name);
  }

  getTitle () {
    var self = this;
    return `${self.title}`;
  }

  log (type = 'Assert', success = false, d, data) {
    var self = this,
      desc = d || `#${++state.logsCounter}`,
      log = {
        type: type,
        success: success,
        desc: desc,
        // message: `${success ? 'Success' : 'Fail'} ${type}: ${desc}`,
        message: `${success ? '✔ Success:' : '❌ Fail:'} ${type}, ${_.capitalize(desc)}`,
      },
      logger = self.getLogger(success);
    self.logs.push(log);
    if (!log.success && data) {
      return console.log(
        log.message,'\n',
        '', _.inspect(data.val), data.desc, _.inspect(data.item)
      );
    }
    if (!self.opts.showAll && log.success) return;
    logger(log.message);
  }

  getLogger (success, finish = false) {
    var self = this,
      failLogger = finish
        ? console.info.bind(console)
        : console.log.bind(console),
      successLogger = console.log.bind(console);
    return !!success ? successLogger : failLogger;
  }

  finish (desc = `#${++state.counter}`) {
    var self = this,
      now = Date.now(),
      success = self.logs.filter(log => !!log.success),
      fail = self.logs.filter(log => !log.success),
      total = success.length + fail.length,
      time = now - self.begin,
      percents = Math.round(success.length / total * 100) || 0,
      isSuccess = fail.length === 0,
      message = `${isSuccess ? '▪  ✅' : '🚫'} ${self.uid} DONE — «${self.getTitle()}»  ▪  💹 ${success.length} / ${success.length + fail.length}`
        + ` (${percents}%)  ▪  ⏳ ${time} millis.`,
      logger = self.getLogger(isSuccess, true);
    self.begin = now;
    self.logs = [];
    logger(message);
  }

  stop (...args) { return this.finish(...args); }

  done (...args) { return this.finish(...args); }

}

function test (title, opts = {}) {
  var test = new Test(title, opts);
  test.start();
  return test;
}

module.exports = test;
