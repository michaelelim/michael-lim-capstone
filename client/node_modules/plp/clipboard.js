var clipboard = {};

clipboard.copy = (function() {
  var _intercept = false;
  var _data = null; // Map from data type (e.g. "text/html") to value.
  var _bogusSelection = false;

  function cleanup() {
    _intercept = false;
    _data = null;
    if (_bogusSelection) {
      window.getSelection().removeAllRanges();
    }
    _bogusSelection = false;
  }

  document.addEventListener("copy", function(e) {
    if (_intercept) {
      for (var key in _data) {
        e.clipboardData.setData(key, _data[key]);
      }
      e.preventDefault();
    }
  });

  // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529
  function bogusSelect() {
    var sel = document.getSelection();
    // If "nothing" is selected...
    if (!document.queryCommandEnabled("copy") && sel.isCollapsed) {
      // ... temporarily select the entire body.
      //
      // We select the entire body because:
      // - it's guaranteed to exist,
      // - it works (unlike, say, document.head, or phantom element that is
      //   not inserted into the DOM),
      // - it doesn't seem to flicker (due to the synchronous copy event), and
      // - it avoids modifying the DOM (can trigger mutation observers).
      //
      // Because we can't do proper feature detection (we already checked
      // document.queryCommandEnabled("copy") , which actually gives a false
      // negative for Blink when nothing is selected) and UA sniffing is not
      // reliable (a lot of UA strings contain "Safari"), this will also
      // happen for some browsers other than Safari. :-()
      var range = document.createRange();
      range.selectNodeContents(document.body);
      sel.removeAllRanges();
      sel.addRange(range);
      _bogusSelection = true;
    }
  };

  return function(data) {
    return new Promise(function(resolve, reject) {
      _intercept = true;
      if (typeof data === "string") {
        _data = {"text/plain": data};
      } else if (data instanceof Node) {
        _data = {"text/html": new XMLSerializer().serializeToString(data)};
      } else if (data instanceof Object){
        _data = data;
      } else {
        reject("Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.")
      }

      function triggerCopy(tryBogusSelect) {
        try {
          if (document.execCommand("copy")) {
            // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis
            // So we can call resolve() back here.
            cleanup();
            resolve();
          }
          else {
            if (!tryBogusSelect) {
              bogusSelect();
              triggerCopy(true);
            } else {
              cleanup();
              throw new Error("Unable to copy. Perhaps it's not available in your browser?");
            }
          }
        } catch (e) {
          cleanup();
          reject(e);
        }
      }
      triggerCopy(false);

    });
  };
})();

clipboard.paste = (function() {
  var _intercept = false;
  var _resolve;
  var _dataType;

  document.addEventListener("paste", function(e) {
    if (_intercept) {
      _intercept = false;
      e.preventDefault();
      var resolve = _resolve;
      _resolve = null;
      resolve(e.clipboardData.getData(_dataType));
    }
  });

  return function(dataType) {
    return new Promise(function(resolve, reject) {
      _intercept = true;
      _resolve = resolve;
      _dataType = dataType || "text/plain";
      try {
        if (!document.execCommand("paste")) {
          _intercept = false;
          reject(new Error("Unable to paste. Pasting only works in Internet Explorer at the moment."));
        }
      } catch (e) {
        _intercept = false;
        reject(new Error(e));
      }
    });
  };
})();

module.exports = {
  copy (...args) {
    clipboard.copy(...args);
  },
  paste (...args) {
    clipboard.paste(...args);
  },
};
