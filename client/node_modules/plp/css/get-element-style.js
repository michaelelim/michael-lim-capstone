import req from 'plp/req';
import Pattern from './element-style-pattern';

const _ = req.hash({
  trim: require('../trim'),
  get: require('../get'),
  set: require('../set'),
  each: require('../each'),
  extend: require('../extend'),
  dasherize: require('../dasherize'),
  camelCase: require('../camelcase'),
  ensureArray: require('../ensure-array'),
  extendUndefined: require('../extend-undefined'),
  util: require('./util'),
});

const state = window.state = {
  props: {},
};

propsTypes(`
  padding, margin, borderRadius
`, {
  'list.space': true,
}, {
  'list.space': false,
});

propsTypes(`
  transition,
`, {
  'list.comma': true,
}, {
  'list.comma': false,
});

propsTypes(`
  width, height,
  top, right, bottom, left,
`, {
  single: true,
}, {
  single: false,
});

class Style {

  constructor (elem) {
    var self = this;
    self.elem = elem;
    self.st = window.getComputedStyle(elem);
    self._data = null;
    self._saved = {};

    self.getData(self);
  }

  getData (d = {}) {
    var self = this,
      data = d || {},
      names = _.util.getPropertyNames('', 'webkit');
    _.each(names, name => {
      if (self[name] !== undefined) return;
      Object.defineProperty(data, name, {
        get () {
          return self.get(name);
        },
        set (val) {
          return self.set(name, val);
        },
      });
    });
    return data;
  }

  extend (data) {
    var self = this;
    _.each(data, (val, name) => {
      self.set(name, val);
    });
    return self;
  }

  get (n, single = false) {
    var self = this,
      name = _.camelCase(n),
      val = self.st.getPropertyValue(_.dasherize(name)),
      pattern = self.getPattern(name),
      vals = self.parse(name, val);
    return (single || self.is(name, 'single')) ? vals[0] : vals;
  }

  set (n, vals) {
    var self = this;
    if (arguments.length === 1 && typeof n === 'object') {
      return self.extend(n);
    }
    if (!Array.isArray(vals)) {
      vals = typeof vals === 'object'
        ? self
          .getPattern(_.camelCase(n))
          .fromObject(vals, _.camelCase(n))
        : [vals];
    }
    requestAnimationFrame(() => {
      self.elem.style[n] = self.dump(n, vals);
    });
    return self;
  }

  getObj (n) {
    var self = this
      name = _.camelCase(n);
    return self.getPattern(name).toObject(self.get(name), name);
  }

  setObj (n, val) {
    var self = this,
      name = _.camelCase(n),
      obj = self.getPattern(name).fromObject(val, name);
    return self.set(name, obj);
  }

  delta (n, v) {
    var self = this,
      name = _.camelCase(n),
      val = self.parse(name, v)[0],
      vals = self
        .get(name)
        .map(current => current + val);
    self.set(name, vals);
    return self;
  }

  is (n, type) {
    var self = this,
      name = _.camelCase(n);
    return !!_.get(state.props[name] || {}, type);
  }

  getPattern (n) {
    var self = this;
    return Pattern.getPattern(n, self);
  }

  parse (n, val) {
    var self = this
      name = _.camelCase(n);
    if (typeof val !== 'string')
      return [val];
    let result = null,
      vals = self.parseList(name, val),
      pattern = self.getPattern(name);
    return vals.map(val => pattern.parse(val, name));
  }

  dump (n, vals) {
    var self = this,
      name = _.camelCase(n),
      result = null,
      pattern = self.getPattern(name),
      values = _
        .ensureArray(vals)
        .map(val => pattern.dump(val, name));
    return self.dumpList(name, values);
  }

  animate (data, d = 1000, f = 'ease') {
    var self = this;
    return new Promise((resolve, reject) => {
      var duration = `${d / 1000}s`,
        transitions = self.transition.slice(0),
        originalTransitions = transitions.slice(0);
      _.each(data, (val, name) => {
        var cur = self.get(name, true);
        self.set(name, cur);
        transitions.push(`${_.dasherize(name)} ${duration} ${f}`);
        setTimeout(() => {
          self.set(name, val);
        }, 0);
      });
      self.transition = transitions;
      setTimeout(() => {
        self.transition = originalTransitions;
        resolve();
      }, d);
    });
  }

  parseList (n, val) {
    var self = this
      name = _.camelCase(n);
    if (name && self.is(name, 'list.space') && val.includes(' ')) {
      return val
        .split(' ')
        .map(s => s.trim())
        .filter(s => !!s);
    }
    if (name && self.is(name, 'list.comma') && val.includes(',')) {
      return val
        .split(',')
        .map(s => s.trim())
        .filter(s => !!s);
    }
    return [val];
  }

  dumpList (n, vals) {
    var self = this
      name = _.camelCase(n);
    if (self.is(name, 'list.space')) {
      return vals.join(' ');
    }
    if (self.is(name, 'list.comma')) {
      return vals.join(', ');
    }
    return vals.join(' ');
  }

  getAllStyles () {
    var self = this,
      names = _.util.getPropertyNames(),
      data = {};
    names.forEach(name => data[name] = self.get(name));
    return data;
  }

  save (name = '_', d = null) {
    var self = this,
      data = d || self.getAllStyles();
    _.set(self._saved, name, data);
    d ? self.extend(d) : '';
    return self;
  }

  restore (name = '_') {
    var self = this,
      data = _.get(self._saved, name);
    self.extend(data);
    return self;
  }

  ghostOn () {
    var self = this;
    self.visibility = 'hidden';
    document.body.appendChild(self.elem);
    return self;
  }

  ghostOff () {
    var self = this;
    self.elem.remove();
    self.visibility = 'visible';
    return self;
  }

}

function getElementStyle(elem) {
  return new Style(elem);
}

function propsTypes(p, data = {}, otherwise = null) {
  var props = p
    .trim()
    .split(',')
    .map(s => s.trim())
    .filter(s => !!s)
    .join(' ');
  props
    .split(' ')
    .forEach(n => {
      var d = state.props[_.camelCase(n)] || {};
      state.props[_.camelCase(n)] = d;
      _.each(data, (val, propName) => {
        _.set(d, propName, val);
      });
    });
  if (!otherwise) return;
  _.util
    .getPropertyNames('', props)
    .forEach(n => {
      var d = state.props[_.camelCase(n)] || {};
      state.props[_.camelCase(n)] = d;
      _.each(otherwise, (val, propName) => {
        _.set(d, propName, val);
      });
    });
}

export default getElementStyle;
