'use strict';

const HttpResponse = require('./http-response.class');

const _ = {
  extend: require('../extend'),
  EventEmitter: require('../event-emitter'),
  each: require('../each'),
  defaults: require('../defaults'),
  type: require('../type'),
  p: require('../p'),
};

const state = {
  events: [
    'loadstart',
    'progress',
    'abort',
    'error',
    'load',
    'timeout',
    'loadend',
  ],
};

class HttpRequest extends _.EventEmitter {

  constructor (url = '', o = {}) { super();
    var self = this;
    _.extend(self, {
      url: url,
      opts: _.defaults(o, {
        method: 'GET',
        mime: undefined,
        responseType: undefined,
      }),
      req: new XMLHttpRequest(),
      resolve: null,
      reject: null,
    });
    self.setEvents();
  }

  on (...args) {
    var self = this;
    if (args.length === 1 && _.type(args[0]) === 'object') {
      _.each(args[0], (cb, name) => super.on(name, cb));
      return self;
    }
    super.on(...args);
    return self;
  }

  emit (...args) {
    var self = this;
    super.emit(...args);
    return self;
  }

  once (...args) {
    var self = this;
    super.once(...args);
    return self;
  }

  setMime (val) {
    var self = this;
    if (!val) return self;
    self.req.overrideMimeType(val);
    return self;
  }

  setResponseType (val) {
    var self = this;
    if (!val) return self;
    self.req.responseType = val;
    return self;
  }

  setCallbacks (resolve, reject) {
    var self = this;
    self.resolve = resolve;
    self.reject = reject;
    return self;
  }

  open (method = 'GET', url = '') {
    var self = this;
    self.req.open(method.toUpperCase(), url);
    return self;
  }

  send () {
    var self = this;
    self.req.send();
    return self;
  }

  request (d = {}) {
    var self = this,
      opts = self.opts,
      data = _.defaults(d, {
        method: opts.method,
        url: self.url,
        mime: opts.mime,
        responseType: opts.responseType,
      }),
      req = self.req;
    return new Promise((resolve, reject) => {
      self
        .open(data.method, data.url)
        .emit('open', data.method, data.url)
        .setMime(data.mime)
        .setResponseType(data.responseType)
        .send()
        .emit('send')
        .emit('progress', 0, 0)
        .setCallbacks(resolve, reject);
    });
  }

  get (d = {}) {
    var self = this;
    d.method = 'GET';
    return self.request(d);
  }

  json (d = {}) {
    var self = this;
    d.responseType = 'json';
    return self.request(d);
  }

  setEvents () {
    var self = this,
      req = self.req;
    _.each(state.events, name => {
      req.addEventListener(name, self[name].bind(self), false);
    });
  }

  loadstart (...args) {
    var self = this,
      req = self.req;
    self.emit('start');
  }

  load (ev) {
    var self = this,
      req = self.req,
      res = new HttpResponse(req, ev);
    self.emit('load', res);
    if (res.success) {
      self.emit('progress', res.loaded, res.total);
      self.emit('success', res);
      return self.resolve(res);
    }
    self.reject(res);
  }

  progress (ev) {
    var self = this,
      req = self.req;
    self.emit('progress', ev.loaded, ev.total);
  }

  error (...args) {
    var self = this,
      req = self.req;
    self.emit('error', ...args);
    self.reject(...args);
  }

  abort (...args) {
    var self = this,
      req = self.req;
    self.emit('abort', ...args);
    self.reject(...args);
  }

  timeout (...args) {
    var self = this,
      req = self.req;
    self.emit('timeout', ...args);
    self.reject(...args);
  }

  loadend (...args) {
    var self = this,
      req = self.req;
    self.emit('end', ...args);
  }

}

module.exports = HttpRequest;
