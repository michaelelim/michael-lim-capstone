'use strict';

const req = require('plp/req');

const _ = req.hash({
  get: require('./get'),
  extend: require('./extend'),
  type: require('./type'),
  queue: require('./queue'),
});

class List {

  constructor (items) {
    var self = this;
    _.extend(self, {
      items,
    });
  }

  parallel (cb = () => {}) {
    var self = this;
    return Promise
      .all(
        self.items.map(item => {
          var result = cb(item);
          if (!(result instanceof Promise))
            result = Promise.resolve();
          return result;
        })
      );
  }

  queue (cb = () => {}) {
    var self = this;
    return new Promise((resolve, reject) => {
      var items = self.get(),
        results = [];
      next();
      function next() {
        if (!items.length)
          return resolve(results);
        var item = items.shift(),
          res = cb(item);
        if (!(res instanceof Promise))
          res = Promise.resolve(res);
        res.then((result) => {
          results.push(result);
          next();
        });
      }
    });
  }

  get length () {
    var self = this;
    return self.items.length;
  }

  each (cb) {
    var self = this;
    self.items.forEach(cb);
    return self;
  }

  get () {
    var self = this;
    return self.items.slice(0);
  }

  max () {
    var self = this;
    return Math.max(...self.items);
  }

  min () {
    var self = this;
    return Math.min(...self.items);
  }

  filter (prop = () => true) {
    var self = this;
    self.items = self.items.filter((item, i) => {
      if (typeof prop === 'function')
        return !!prop(item, i);
      return item === prop;
    });
    return self;
  }

  map (prop) {
    var self = this;
    self.items = self.items.map((item, i) => {
      if (typeof prop === 'string')
        return _.get(item, prop);
      if (!isNaN(+prop) && _.type.isLikeArray(item))
        return item[+prop];
      if (typeof prop === 'function')
        return prop(item, i);
      return item;
    });
    return self;
  }

  sort (prop) {
    var self = this;
    self.items = self.items.sort((item, i) => {
      if (typeof prop === 'string')
        return (a, b) => a[prop] > b[prop] ? 1 : -1;
      if (typeof prop === 'function')
        return prop;
      return a > b ? 1 : -1;
    });
    return self;
  }

  toString () {
    var self = this;
    return self.valueOf() + '';
  }

  valueOf () {
    var self = this;
    return self.by();
  }
}

function list(...args) {
  var items = getItems(args);

  var c = new List(items);
  return c;

  function getItems(datas) {
    if (args.length === 1 && _.type.isLikeArray(args[0])) {
      return Array.from(args[0]);
    }
    return Array.from(args);
  }
}

_.extend(list, {
  List,
});

(['map', 'filter', 'min', 'max', 'each', 'parallel', 'queue']).forEach(name => {
  list[name] = (items, ...args) => {
    return (list(...items))[name](...args).get();
  };
});

module.exports = list;
