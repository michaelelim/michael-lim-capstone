'use strict';

const util = module.exports = {};

const _ = require('lodash');
const fs = require('fs');
const path = require('path');
const md5 = require('md5');
const EventEmitter = require('./event-emitter');
const Hash = require('./hash');

_.extend(util, {

  flatten, flat: flatten,
  pickExt, removeTags,
  isObject, notObject,
  buildClient, md5,
  resolver, argsList,
  toMethod, injectMethods,
  createFunction, expression,
  roundMin, roundMax,
  EventEmitter, Hash,
  getClassMethods, getStaticMethods,
  objectsToArray,

}, require('./fs'));

function objectsToArray(data, propName = '_name') {
  return Object.keys(data).map(name => {
    var obj = data[name];
    if (!obj || typeof obj !== 'object') {
      return;
    }
    obj[propName] = name;
    return obj;
  }).filter(item => !!item);
}

function getClassMethods(Class) {
  var exclude = ['constructor', 'length'];
  return Object
    .getOwnPropertyNames(Class.prototype)
    .filter(name => !exclude.includes(name));
}

function getStaticMethods(Class) {
  var exclude = ['length', 'name', 'prototype'];
  return Object
    .getOwnPropertyNames(Class)
    .filter(name => !exclude.includes(name));
}

function roundMin (x, step) {
  return Math.ceil(x - x % step);
}

function roundMax (x, step) {
  return Math.ceil(x - x % step + step);
}

function expression(source, ctx) {
  var fn = createFunction(`return ${source};`, ctx);
  return fn();
}

function createFunction(source, ctx, args) {
  var context = ctx || {},
    names = _.keys(context),
    values = _.values(context),
    argsStr = names.concat(args || []).join(','),
    fn = new Function(argsStr, source);

  return function (...args) {
    return fn.apply(
      context.self || null,
      values.concat(args)
    );
  };
}

function injectMethods(target, source) {
  _.each(source, (method, name) => {
    if (typeof method !== 'function') {
      return;
    }
    target[name] = toMethod(method);
  });
  return target;
}

function toMethod(fn) {
  return function (...args) {
    args.unshift(this);
    return fn.apply(this, args);
  };
}

function argsList(fn) {
  var re = /function\s+(?:[^\(]+)?\s*\(([^\)]+)/i,
    source = fn.toString(),
    result = re.exec(source) || [],
    argsStr = result[1],
    args = argsStr ? argsStr.split(',') : [];

  return args
    .map(name => name.trim())
    .filter(name => !!name);
}

function removeTags (code) {
  return code.replace(/\<[^\>]+\>/mgi, '').trim();
}

function resolver(dir) {
  return file => path.resolve(dir, file);
}

function buildClient(filename) {
  var dir = path.dirname(filename),
    source = fs.readFileSync(filename, 'utf-8');
  source = source.replace(/\@import\(\'(.+?)\'\)/mgi, (txt, file) => {
    var filename = path.resolve(dir, file);
    return buildClient(filename);
  });
  return source;
}

function isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item);
}

function notObject(item) {
  return isObject(item);
}

function pickExt(file, items) {
  var ext = '',
    exts = _.clone(items || [
      '/index.yaml',
      '/index.yml',
      '/index.cortml',
      '/index.cml',
      '.yaml',
      '.yml',
      '.cortml',
      '.cml',
      '',
    ]),
    filename = '';
  while (exts.length > -1 && ext !== undefined) {
    filename = file + ext;
    if (util.existsFile(filename)) {
      return filename;
    }
    ext = exts.pop();
  }
  return null;
}

function flatten(obj, parentName) {
  if (Array.isArray(obj)) {
    obj = _.toPlainObject(obj);
  }
  if (!obj || typeof obj !== 'object') {
    return obj;
  }
  var data = {};
  parentName = parentName || '';
  Object.keys(obj).forEach((name) => {
    var val = obj[name];
    name = parentName ? parentName + '.' + name : name;
    if (typeof val !== 'object') {
      data[name] = val;
      return;
    }
    Object.assign(data, flatten(val, name));
  });
  return data;
}
