'use strict';

const _ = require('lodash');
const path = require('path');
const webpack = require('webpack');
const gutil = require('gutil');
const colorsSupported = require('supports-color');
const cml = require('cortml');
const chokidar = require('chokidar');
const fs = require('fs-extra');
const wrench = require('wrench');

const config = cml.loadFile(path.resolve(__dirname, '../../config.yaml')).webpack;

class Pack {

  constructor (opts = {}) {
    var self = this,
      context = opts.context,
      entry = opts.entry,
      output = opts.output || {
        path: path.join(context, 'dist'),
        filename: 'js/app.pack.js',
      },
      outputPath = output.path || path.join(context, 'dist'),
      pagePath = path.relative(context, path.resolve(outputPath, entry));

    _.extend(self, {
      opts: opts,
      context: context,
      entry: entry,
      output: {
        path: output.path || path.join(context, 'dist'),
        filename: output.filename || 'js/app.pack.js',
        library: output.library || null,
        libraryTarget: output.libraryTarget || null,
      },
      exts: config.exts,
      dirs: config.dirs.concat([
        path.resolve(__dirname, '../../../packages'),
      ]),
      loaders: self.renderLoaders(),
      // loaders: self.getLoaders(),
      outputFilename: path.resolve(output.path, output.filename),
    });
  }

  run () {
    var self = this;
    return new Promise((resolve, reject) => {
      var config = _.extend({}, self.getConfig()),
        compiler = webpack(config);

      compiler.run((err, stats) => {
        if (err) { return self.handleError(err); }
        self.showStats(stats);
        return resolve(fs.readFileSync(self.outputFilename, 'utf-8'));
        
        chokidar
          .watch([
            self.outputFilename,
          ])
          .on('add', () => {
            resolve(fs.readFileSync(self.outputFilename, 'utf-8'));
          });
      });
    });
  }

  watch () {
    var self = this;
    return new Promise((resolve, reject) => {
      var config = _.extend({}, self.getConfig()),
        compiler = webpack(config),
        done = false;

      compiler.watch(config.watchSettings, (err, stats) => {
        if (err) { return self.handleError(err); }
        self.showStats(stats);
        if (!done) resolve(fs.readFileSync(self.outputFilename, 'utf-8'));
        done = true;
      });
    });
  }

  getConfig () {
    var self = this,
      CONFIG = {
        context: self.context,
        entry: self.entry,
        output: {
          path: self.output.path,
          filename: self.output.filename,
          publicPath: '',
          library: self.output.library || null,
          libraryTarget: self.output.libraryTarget || null,
        },
        resolve: {
          extensions: self.exts,
          modulesDirectories: self.dirs || [],
          root: self.root || [],
        },
        plugins: [],
        htmlLoader: {
          ignoreCustomFragments: [/\{\{.*?}}/]
        },
        module: {
          loaders: self.loaders,
        },
      };
    return CONFIG;
  }

  getLoaders () {
    var self = this,
      loaders = [];
    return Object.keys(config.loaders).map(name => {
      var data = config.loaders[name];
      return {
        test: new RegExp(data.test),
        exclude: data.exclude || [],
        loader: data.loader,
        query: {
          presets: (data.props || {}).presets || [],
          plugins: (data.props || {}).plugins || []
        }
      };
    });
  }

  renderLoaders () {
    var self = this,
      keys = Object.keys(config.loaders);
    return keys.map((name) => {
      var data = config.loaders[name],
        query = [],
        loader = name;
      _.each(data.props, (val, name) => {
        query.push(Array.isArray(val)
          ? val.map(v => `${name}[]=${v}`).join('&')
          : `${name}=${val}`);
      });
      if (query.length) {
        loader += `?${query.join('&')}`;
      }
      return {
        test: new RegExp(data.test),
        exclude: data.exclude || [],
        loader: loader,
      };
    });
  }

  showStats (stats) {
    var self = this;
    if (self.opts.logLevel === 0) {
      return;
    }
    gutil.log('[webpack]', stats.toString({
      colors: colorsSupported,
      chunks: false,
      errorDetails: true
    }));
  }

  handleError (err) {
    var self = this;
    console.error(gutil.PluginError('webpack', err).stack);
  }

}

module.exports = Pack;
