import EventEmitter from 'util/event-emitter';

const EVENTS = ['error', 'click', 'close', 'show'];
const STATUS = {
  DEFAULT: 'default',
  GRANTED: 'granted',
  DENIED: 'denined',
};

class Notify extends EventEmitter {

  constructor () { super();
    var self = this;
    self.permitted = false;
    self.message = '';

    self.on('permitted', () => {
      self.permitted ? '' : console.info('Notifications are permitted!');
      self.permitted = true;
    });
    self.initService();
  }

  show (title = '', opts = {}) {
    var self = this;
    self
      .initService()
      .then(() => self.createNotification(title, opts));
  }

  createNotification (title = '', opts = {}) {
    var self = this,
      options = self.verifyOptions(opts),
      item = new Notification(title, options);
    self.setEvents(item, options);
    options.timeout ? setTimeout(() => item.close(), options.timeout) : '';
  }

  get permission () {
    var self = this;
    return Notification.permission;
  }

  verifyOptions (options) {
    var self = this;
    options.timeout = options.timeout || 10000;
    options.body = options.body || '';
    options.icon = options.icon || self.getColoredImage(options.color);
    return options;
  }

  setEvents (item, options) {
    var self = this;
    _.each(EVENTS, name => {
      item.addEventListener(name, ev => {
        var action = options[`on${_.capitalize(name)}`];
        if (!action) { return; }
        action(ev, item);
        item.close();
      }, false);
    });
  }

  getColoredImage (i = 1) {
    var self = this;
    return `http://lab.lpchat.ru/s/assets/avatars/colors/${i}.jpg`;
  }

  initService () {
    var self = this;
    return new Promise((resolve, reject) => {
      if (self.permission === STATUS.GRANTED) {
        self.emit('permitted');
        return resolve();
      }
      if (!window.hasOwnProperty('Notification')) {
        self.message = 'Browser doesn\'t support notifications!';
        self.emit('denined');
        return reject();
      }
      if (self.permission === STATUS.GRANTED) {
        self.emit('permitted');
        return resolve();
      }
      if (self.permission !== STATUS.DENIED) {
        Notification
          .requestPermission()
          .then(permission => {
            if (permission === STATUS.GRANTED) {
              self.emit('permitted');
              resolve();
            }
          });
        return;
      }
      self.emit('denined');
      reject();
    });
  }

}

module.exports = new Notify();
