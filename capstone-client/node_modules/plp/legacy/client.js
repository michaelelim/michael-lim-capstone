import EventEmitter from 'util/event-emitter';
import config from 'json/config';

export default class Client extends EventEmitter {

  constructor (url) { super();
    var self = this;

    self.url = url;
    self.ws = null;
    self.connected = false;
    self.waiting = [];
    self.rpc = {};
    self.balance = 0;
    self.counter = 0;
    self.config = config;
    self.debug = !!self.config.debug;

    self.setEvents();
    self.connect();
  }

  uniqueId () {
    var self = this;
    return ++self.counter;
  }

  send (message) {
    var self = this;
    if (!self.connected) {
      self.waiting.push(message);
      return;
    }
    self.ws.send(message);
  }

  connect () {
    var self = this;
    return new Promise((resolve, reject) => {
      self.ws = new WebSocket(self.url);
      self.setSocketEvents();
    });
  }

  call (name, data) {
    var self = this;
    return new Promise((resolve, reject) => {
      var uid = `rpc-${self.uniqueId()}`,
        request = {
          uid: uid,
          type: 'rpc',
          data: data,
          name: name
        },
        content = JSON.stringify(request);
      self.rpc[uid] = resolve;
      self.send(content);
    });
  }

  setEvents () {
    var self = this;
    self.on('message', content => {
      var response = JSON.parse(content);
      if (response.type === 'rpc' && self.rpc[response.uid]) {
        self.rpc[response.uid](response.data);
        return;
      }
    });
  }

  setSocketEvents () {
    var self = this,
      ws = self.ws;
    ws.onopen = () => {
      self.debug ? console.info('Socket connected.') : '';
      self.balance++;
      self.connected = true;
      self.emit('connected');
      self.waiting.forEach(content => ws.send(content));
      self.waiting = [];
    };
    ws.onmessage = response => {
      self.emit('message', response.data, response);
    };
    ws.onclose = () => {
      self.debug ? console.info('Socket disconnected.') : '';
      self.balance--;
      self.connected = false;
      if (self.balance < -1) {
        setTimeout(() => self.connect(), 1000);
      } else {
        self.connect();
      }
    };

  }

}
