const LOCAL_EVENTS = [
  'connected',
  'disconnected',
  'closed',
  'broken',
  'reconnected',
  'error',
  'message',
];

const READY_STATES = [
  'connecting',
  'connected',
  'disconnecting',
  'disconnected',
];

class Socket {

  constructor (url, options) {
    var self = this;

    Object.defineProperties(self, {
      _handlers: {
        value: {
          local: {},
          socket: {},
        },
      },
      _waiting: {
        value: [],
        writable: true,
      },
      _rpcCallbacks: {
        value: {},
      },
      _counter: {
        value: 0,
        writable: true,
      },
    });

    Object.assign(self, {
      // url: url || '',
      url: `ws://${location.hostname}:14001`,
      // ws: null,
      options: Object.assign({}, {
        reconnect: true,
        reconnectAfter: 1000,
        binaryType: 'arraybuffer',
      }, options),
    });

    self._setSocketEvents();
  }

  // Com methods ===============================================================

  send (content) {
    var self = this,
      ws = self.ws;
    if (!self.connected) {
      return self._waiting.push(content);
    }
    ws.send(content);
  }

  call (name, d) {
    var self = this,
      data = d || {};
    return new Promise((resolve, reject) => {
      try {
        var uid = self._uniqueId(),
          type = 'rpc',
          request = {
            type, uid, name, data,
          },
          content = JSON.stringify(request);
        self.send(content);
        self._rpcCallbacks[uid] = resolve;
      } catch(err) {
        reject(err);
      }
    });
  }

  // Local storage =============================================================

  getLocalData () {
    var self = this,
      data = {};
    Object
      .keys(localStorage)
      .forEach(key => data[key] = localStorage.getItem(key));
    return data;
  }

  setLocalData (data) {
    var self = this;
    Object
      .keys(data)
      .forEach(key => {
        var val = data[key];
        if (val === null) {
          return localStorage.removeItem(key);
        }
        localStorage.setItem(key, data[key]);
      });
    return self;
  }

  // Service methods ===========================================================

  getStatus () {
    var self = this,
      ws = self.ws;
    if (!ws) {
      return 'init';
    }
    return READY_STATES[ws.readyState];
  }

  get status () {
    var self = this;
    return self.getStatus();
  }

  isConnected () {
    var self = this;
    return self.status === 'connected';
  }

  get connected () {
    var self = this;
    return self.isConnected();
  }

  connect () {
    var self = this,
      ws;

    try {
      ws = self.ws = new WebSocket(self.url, 'soap');
    } catch(err) {
      console.debug('Socket error.');
      throw err;
      return self.emit('error', err);
    }

    ws.binaryType = self.options.binaryType || 'blob';

    ws.addEventListener('open', ev => {
      self.emit('connected', ev);
      console.debug('Socket connected.');
    }, false);

    ws.addEventListener('close', ev => {
      if (ev.wasClean) {
        self.emit('closed', ev);
        console.debug(`Socket successfully closed. Code: ${ev.code}.`, ev);
      } else {
        self.emit('broken', ev);
        console.warn(`Socket connection broken. Code: ${ev.code}.`, ev);
      }
      self.emit('disconnected', ev);
    }, false);

    ws.addEventListener('message', ev => {
      self.emit('message', ev.data, ev);
    }, false);

    ws.addEventListener('error', err => {
      self.emit('error', err);
      console.debug('Socket error.');
    }, false);
  }

  reconnect () {
    var self = this;
    self.disconnect();
    self.connect();
  }

  disconnect () {
    var self = this,
      ws = self.ws;
    if (!ws) {
      return;
    }
    ws.close();
  }

  on (name, handler, once = false) {
    var self = this;
    self._list(name).push({
      once,
      handler
    });
  }

  once (name, handler) {
    var self = this;
    return self.on(name, handler, true);
  }

  emit (name, ...args) {
    var self = this;
    if (!self._isLocal(name)) return;
    return self._emit(name, ...args);
  }

  // Internal ==================================================================

  _uniqueId () {
    var self = this;
    return `rpc-${++self._counter}`;
  }

  _setSocketEvents () {
    var self = this;
    self.on('broken', ev => {
      if (!self.options.reconnect) return;
      setTimeout(() => {
        self.connect();
      }, self.options.reconnectAfter);
    });
    self.on('message', (content, ev) => {
      var res = JSON.parse(content);
      if (res.type === 'rpc' && self._rpcCallbacks.hasOwnProperty(res.uid)) {
        self._rpcCallbacks[res.uid](res.data);
        return delete self._rpcCallbacks[res.uid];
      }
      if (res.type === 'event') {
        return self._emit(res.name, res.data);
      }
    });
    self.on('connected', (ev) => {
      var messages = self._waiting.slice(0);
      self._waiting = [];
      messages.forEach(content => self.send(content));
    });
  }

  _list (name) {
    var self = this,
      isLocal = self._isLocal(name),
      handlers = isLocal ? self._handlers.local : self._handlers.socket,
      list = handlers[name];
    list ? '' : (handlers[name] = list = []);
    return list;
  }

  _isLocal (name) {
    var self = this;
    return LOCAL_EVENTS.includes(name);
  }

  _emit (name, ...args) {
    var self = this,
      list = self._list(name);
    list.forEach((item, i) => {
      item.handler(...args);
      item.once ? list.splice(i, 1) : '';
    });
  }

}

module.exports = Socket;
